; The first token in a lisp is the label/name of this list
; This self-describing token is visible to its parent (the file its defined in) as well as any sub-universes
; but is not available outside of it

(
Universe
; Nandalisp
;
; parentheses, spaces, and sinqle quotes are reserved as special characters
; all other printable characters can be used as tokens.
; if you want to use a reserved character as a symbol, escape it with a backslash.
; \)
; \(
; \
; \\
; \'
; All constructs are expressed as lists
; All lists are sequences
; All sequences are iterators
; The first token will produce a list of the subsequent tokens.
; Or, in other words, the head is the token that represents/produces the tail
; by convention, we use lower case for concrete values and upper case for abstract
; types who's value has not been determined
;
; if a token in a list has not already been introducted (at the top level of a list), it is assumed to be local,
; and local refernceable within that list
; if a token has previously been defined at the top level of a list,
; then using that token in another list is presumed to represent the defined data structure
;
; the Pipe (|) symbol indicates sequential alternation.
; While commas (after the initial one) represent nested data structures
;
; Defines the tokens that we will be using in our Univser. These one element lists can be considered
; single value iterators over the labels themselves

FALSE TRUE
0 1 2 3 4 5 6 7 8 9
a b c d e f g h i j k l m n o p q r s t u v w x y z
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

; Defines a BOOL token/struct such that asking for a bool will return a sequence that is first false then true
; Because we introduced FALSE and TRUE as top level (to this universe) tokens right above, any usage of that token will be refencing the top level one
; Defines a BOOL token/struct such that asking for a bool will return a sequence that is first false then true
; path-length 2
(BOOL FALSE TRUE)

; Same for bit. Asking for a BIT will return a 0 then a 1, in that order
(BIT 0 1)
(BIT BOOL) ; This should be a synonym for above, due to structural identity

; Note that because BOOL and BIT have structural equivalency (they both contain two non repeating tokens and nothing else)
; they are effectively aliases for each other, and a BOOL:true is the same as a BIT:1, in that they both represent
; the second value in types that contain exactly two values. This is by design and should not be a surprise

; Asking for a Digit will return digits between 0 and 9, in order, one at a time
(DIGIT 0 1 2 3 4 5 6 7 8 9)
; Let's create an alias for a digit. Note that any single character token can be combined with
; other single character tokens into a sequence without including spaces or repeating the identifier
;(# DIGIT)

(UPPERCASE_LETTER A B C D E F G H I J K L M N O P Q R S T U V W X Y Z)
(LETTER UPPERCASE_LETTER)
(LOWERCASER_LETTER a b c d e f g h i j k l m n o p q r s t u v w x y z)


; All constructs are expressed as lists
; All lists are sequences
; All sequences are iterators
; The first token will produce a list of the subsequent tokens.
; Or, in other words, the head is the token that represents/produces the tail
; by convention, we use lower case for concrete values and upper case for abstract
; types who's value has not been determined

; if a token in a list has not already been introducted (at the top level of a list), it is assumed to be local,
; and local refernceable within that list
; if a token has previously been defined at the top level of a list,
; then using that token in another list is presumed to represent the defined data structure


; Note that because BOOL and BIT have structural identity (they both contain two non repeating tokens and nothing else)
; they are effectively aliases for each other, and a BOOL:true is the same as a BIT:1, in that they both represent
; the second value in types that contain exactly two values. This is by design and should not be a surprise

; Asking for a Digit will return digits between 0 and 9, in order, one at a time
; path length 10
(DIGIT 0 1 2 3 4 5 6 7 8 9)

; a PAIR is a nested set of two BITs. path length 4
(PAIR BIT BIT)
(TRIPLE BIT BIT BIT) ; path length 8
;a Triple can also be expressed as the combination of a PAIR and a BIT, if it is helpful
(TRIPLE PAIR BIT) ; same because same path bit sequence
(TRIPLE BIT PAIR) ; same because same path bit sequence

;Asking for a BYTE will return a BIT, containing a second Bit, repeatedly until 8 bits have been produced.
; path length 256
(NIBBLE PAIR PAIR)

; Both of these expand to a path length of 256, and are therefore identical
(BYTE BIT BIT BIT BIT BIT BIT BIT BIT)
(BYTE NIBBLE NIBBLE)
; Asking for a two digit number will return one DIGIT followed by another DIGIT
; path length 100
(TWODIGITNUM DIGIT DIGIT)

; Asking for a bignum will return a sequence of 16 digits; path length 10^16
(BIGNUM DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT)

; previously defined (multi-valued) data types function as wholes/inputs into the DAGs that can be constructed from these lists
; If you ask for a NAND, you will get two nested bits of input, representing four possible states,
; and the combination of those two bits will generate one of two outputs
; The head is two nested bits. The tail is a four token sequence. The fact that there are fewer distinct
; output values (2) than distinct input values (4), means that this operation will not be reversible once evaluated/flattened
 (NAND PAIR 1 1 1 0)

; NOT can be defined as the input sequence 0|1 producing the output sequence 1|0
(NOT BIT 1 0)
(NOT (O 1) 1 0)
; As a convenience, we introduce one more bit of syntax.
; in an expression, a TOKEN followed by :# where # is a number binds those inputs to be the same value,
; even if they appear in different places
; NOT can then be defined in terms of NAND
; here we redefine NOT so that it produces a NAND where both inputs must be the same, leading to two input possibilities,
; and the output toeksn
; For all possibile inputs, the two NOT definitions produce identical output

; AND is defined with an inverse truth table as NAND
; AND can be defined in terms of  NAND and NOT
(AND PAIR 0 0 0 1)
(AND ((0 0) (0 1) (1 0) (1 1)) 0 0 0 1)
(AND PAIR NAND NOT)

; As long as all definitions of a token can be proven to generate identical output for all inputs,
; they can be substituted for each other at the compiler's discretion. If their definitions conflict and produce differing output,
; or have different input structure, then a compile error occurs

( OR PAIR 0 1 1 1 )
( OR ( (0 0) (0 1) (1 0) (1 1) ) 0 1 1 1 )
( OR PAIR (NOT NOT) NAND )

; NOR, defined either natively, or in terms of NOT and OR
( NOR PAIR 1 0 0 0 )
(NOR PAIR OR NOT)

(XOR PAIR 0 1 1 0)

(XOR (PAIR :A :B) ( B A AND ) ( A B AND ) NAND  )

(XOR
    PAIR (:0 ( ) ( (:NAND) NAND ) NAND
    AND ( NAND ( PAIR ) OR ( PAIR ))
))

(XNOR PAIR 1 0 0 1)
( XNOR
    PAIR
    NOT ( XOR ( PAIR ) ) )

(HALFCARRY AND PAIR)

(HALFADDER (PAIR PAIR) (HALFSUM HALFCARRY)
)

(FULLSUM
    HALFSOME ( HALFSOME ( PAIR ) BIT )
)


(MUX TRIPLE 0 0 1 1 0 1 0 1)
; This destructures the input TRIPLE into 3 sepearately referanceable values (A, B, and S), allowing their reuse multiple times within the structure
;(MUX TRIPLE(A, B, S) OR ( AND A NOT( S ) ) ( AND B S ))

; a NIBBLE is a sequence of four BITs. path-length 16
(NIBBLE BIT BIT BIT BIT)
;a BYTE is a sequence of 8 BITS. path-length 256
(BYTE BIT BIT BIT BIT BIT BIT BIT BIT)
;a BYTE can also be identically defined in terms of two NIBBLES. identical because it has an identical
;path length to the previous definition
(BYTE NIBBLE NIBBLE)

; Asking for a two digit number will return one DIGIT followed by another DIGIT
(TWODIGITNUM DIGIT DIGIT)

; Asking for a bignum will return a sequence of 16 digits
(BIGNUM DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT DIGIT)

; previously defined (multi-valued) data types function as wholes/inputs into the DAGs that can be constructed from these lists
; If you ask for a NAND, you will get two nested bits of input, representing four possible states,
; and the combination of those two bits will generate one of two outputs
; The head is two nested bits. The tail is a four token sequence. The fact that there are fewer distinct
; output values (2) than distinct input values (4), means that this operation will not be reversible once evaluated/flattened
 (NAND PAIR 1 1 1 0)

; NOT can be defined as the input sequence 0|1 producing the output sequence 1|0
(NOT PAIR 1 0)
(NOT BIT (NAND BIT BIT))
; As a convenience, we introduce one more bit of syntax.
; in an expression, a TOKEN followed by :# where # is a number binds those inputs to be the same value,
; even if they appear in different places
; NOT can then be defined in terms of NAND
; here we redefine NOT so that it produces a NAND where both inputs must be the same, leading to two input possibilities,
; and the output toeksn
; For all possibile inputs, the two NOT definitions produce identical output

; AND is defined with an inverse truth table as NAND
; AND can be defined in terms of  NAND and NOT
(AND PAIR 0 0 0 1)
(AND PAIR (BIT 1 0))

; As long as all definitions of a token can be proven to generate identical output for all inputs,
; they can be substituted for each other at the compiler's discretion. If their definitions conflict and produce differing output,
; or have different input structure, then a compile error occurs

(OR PAIR 0 1 1 1 )
; valid because OR simplifies into another version of OR
(OR (PAIR A B) NAND ( NOT ( A ) NOT ( B ) ) )


; NOR, defined either natively, or in terms of NOT and OR
(NOR PAIR 1 0 0 0)
(NOR PAIR NOT OR )

(XOR PAIR 0 1 1 0)
(XOR PAIR AND ( ( NAND : ) ( OR : ) ) )

(XNOR PAIR 1 0 0 1)

(XNOR (PAIR A B)
    ( NAND
           ( NAND ( NAND A ( NAND A B ) ) ( NAND B ( NAND A B ) ) )
           ( NAND ( NAND A ( NAND A B ) ) ( NAND B ( NAND A B ) ) ))
)


(HALFCARRY AND)

(HALFADDER (HALFSUM) (HALFCARRY))

(FULLSUM HALFSOME ( HALFSOME ( PAIR ) BIT ) )

)